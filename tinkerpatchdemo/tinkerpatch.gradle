apply plugin : 'tinkerpatch-support'

/**
 * TODO: 请按自己的需求修改为适应自己工程的参数
 */
def bakPath = file("${buildDir}/bakAPk")

def baseInfo = "tinkerdemo-1.0.0-0806-11-11-06"
def variantName = "release"


/**
 * 对于插件各参数的详细解析请参考
 * http://tinkerpatch.com/Docs/SDK
 */
tinkerpatchSupport {
    /** 可以在debug的时候关闭 tinkerPatch **/
    tinkerEnable = true

    /** 是否使用一键接入功能  **/
    reflectApplication = true

    /** 是否开启加固模式，只有在使用加固时才能开启此开关 **/
    protectedApp = false

    /** 补丁是否支持新增 Activity (exported必须为false)**/
    supportComponent = true

    /**
     * 将每次编译产生的 apk/mapping.txt/R.txt 归档存储的位置
     */
    autoBackupApkPath = "${bakPath}"

    /** 在tinkerpatch.com得到的appKey **/
    appKey = "6551ec1d216fe1c1"
    /** 注意: 若发布新的全量包, appVersion一定要更新 **/
    appVersion = "1.0.0"

    def pathPrefix = "${bakPath}/${baseInfo}/${variantName}"
    def name = "${project.name}-${variantName}"

    /**
     * 基准包的文件路径, 对应 tinker 插件中的 oldApk 参数;编译补丁包时，必需指定基准版本的 apk，默认值为空，
     * 则表示不是进行补丁包的编译。
     */
    baseApkFile = "${pathPrefix}/${name}.apk"
    /**
     *基准包的 Proguard mapping.txt 文件路径, 对应 tinker 插件 applyMapping 参数；在编译新的 apk 时候，
     * 我们希望通过保持基准 apk 的 proguard 混淆方式，
     * 从而减少补丁包的大小。这是强烈推荐的，编译补丁包时，我们推荐输入基准 apk 生成的 mapping.txt 文件。
     */
    baseProguardMappingFile = "${pathPrefix}/${name}-mapping.txt"
    /**
     * 	基准包的资源 R.txt 文件路径, 对应 tinker 插件 applyResourceMapping 参数；在编译新的apk时候，
     * 	我们希望通过基准apk的R.txt 文件来保持 Resource Id 的分配，
     * 	这样不仅可以减少补丁包的大小，同时也避免由于 Resource Id 改变导致 remote view 异常。
     */
    baseResourceRFile = "${pathPrefix}/${name}-R.txt"


    /**
     * （可选）重命名备份文件的格式化字符串，默认为'${appName}-${variantName}'
     *
     * Available vars:
     * 1. projectName
     * 2. appName
     * 3. packageName
     * 4. buildType
     * 5. versionName
     * 6. versionCode
     * 7. buildTime
     * 8. fileSHA1
     * 9. flavorName
     * 10. variantName
     *
     * default value: '${appName}-${variantName}'
     * Note: plz use single-quotation wrapping this format string
     */
    backupFileNameFormat = '${appName}-${variantName}'

    /**
     *  若有编译多flavors需求, 可以参照： https://github.com/TinkerPatch/tinkerpatch-flavors-sample
     *  注意: 除非你不同的flavor代码是不一样的,不然建议采用zip comment或者文件方式生成渠道信息（相关工具：walle 或者 packer-ng）
     **/
}

 /**
 * 用于用户在代码中判断tinkerPatch是否被使能
 */
 android {
    defaultConfig {
        buildConfigField "boolean", "TINKER_ENABLE", "${tinkerpatchSupport.tinkerEnable}"
    }
 }

/**
 * 一般来说,我们无需对下面的参数做任何的修改
 * 对于各参数的详细介绍请参考:
 * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97
 */
tinkerPatch {
    ignoreWarning = false
    useSign = true
    dex {
        dexMode = "jar"
        pattern = ["classes*.dex"]
        loader = []
    }
    lib {
        pattern = ["lib/*/*.so"]
    }

    res {
        pattern = ["res/*", "r/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]
        ignoreChange = []
        largeModSize = 100
    }

    packageConfig {
    }
    sevenZip {
        zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
//        path = "/usr/local/bin/7za"
    }
    buildConfig {
        keepDexApply = false
    }
}

import java.util.regex.Matcher
import java.util.regex.Pattern

/**
 * 如果只想在Release中打开tinker，可以把tinkerEnable赋值为这个函数的return
 * @return 是否为release
 */
def isRelease() {
    Gradle gradle = getGradle()
    String  tskReqStr = gradle.getStartParameter().getTaskRequests().toString()

    Pattern pattern;
    if (tskReqStr.contains("assemble")) {
        println tskReqStr
        pattern = Pattern.compile("assemble(\\w*)(Release|Debug)")
    } else {
        pattern = Pattern.compile("generate(\\w*)(Release|Debug)")
    }
    Matcher matcher = pattern.matcher(tskReqStr)

    if (matcher.find()) {
        String task = matcher.group(0).toLowerCase()
        println("[BuildType] Current task: " + task)
        return task.contains("release")
    } else {
        println "[BuildType] NO MATCH FOUND"
        return true;
    }
}
